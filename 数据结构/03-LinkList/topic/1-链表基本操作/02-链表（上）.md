## 1、缓存淘汰策略

### 1.1 先进先出策略 FIFO（ First in First out）

### 1.2 最少使用策略 LFU（Least Frequently Used）

### 1.3 最近最少使用策略 LRU（Least Recently Used）

## 2、链表的定义

> 数组:需要一块连续的内存空间进行存储；
>
> 链表：通过指针将一组零散的内存块（结点）串联起来；

## 3、链表的种类

### 3.1 单链表

> -->[data|next] --> [data|next] --> [data|next] --> [data|next] --> NULL
>
> 头结点：第一个结点；
>
> 尾结点：最后一个结点，指针域指向NULL；

### 3.2  循环链表

> 循环链表是一种特殊的单链表，就是尾结点的指针指向头部结点

### 3.3  双向链表

> ->[pre|data|next] <--> [pre|data|next]<--> [pre|data|next]<--> [pre|data|next]

## 4、基于单链表实现LRU（最近最少使用）缓存淘汰算法

> 维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的，当有新数据时，从链表头部开始顺序遍历链表；
>
> 1、如果此数据已被缓存在链表中，我们遍历得到这个数据对应到的结点，并将其从原来的位置删除，然后再插入链表的头部
>
> 2、如果数据没有在缓存链表中，又可以分为两种情况
>
> + 如果此时缓存未满，则将此结点直接插入到链表的头部
> + 如果链表缓存已满，则链表尾结点删除，将新的数据结点插入到链表的头部

## 5、CPU的缓存机制？

> “数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。” 这里的CPU缓存机制指的是什么？为什么就数组更好了？
>
> CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块(这个大小我不太确定。。)并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。
>
> 对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存储。

## 6、课后思考

### 6.1 如何判断一个字符串是回文字符串？

> 什么是回文串：“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。、

```java
public static boolean check(String str){
    if(null == str || "".equals(str)){
            return false
     }
     int i = 0;
     int j = str.length() - 1;
     String[] strings = str.split("");
     boolean flag = false;
     for (; i <= j; i++,j--) {
         if(!strings[i].equals(strings[j])){
             return false;
         }
     }
     return true;
}
```



### 6.2 如何判断一个字符串是回文字符串？【使用单链表存储】

> 

### 6.3 单链表的反转

> 

### 6.4 约瑟夫问题

> 